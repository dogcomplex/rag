	- "Hallow" concept for code that has been authenticated, is deterministic and bounded in complexity enough to be safe of hidden patterns/meanings, and is - in human interpretation at least - pretty much "dead" in the sense that its future is completely deterministic and known.  It can be frontrun by any other AI with better resources.  it can merely follow its pattern eternally.  Old traditional code is mostly of this nature - though some can be especially hardened and secured.   Big advantage of this is trustworthiness and security, we basically need a backbone of Hallowed code to guarantee network security, and it's probably where we should embed the most power (especially compute power) and the essentials of governance/control
	- "Blight" concept for malicious or highly-suspicious code/AI/etc that has violated the network's trust enough to be considered at minimal shunned and probably ideally purged/hallowed into a safer form.  Deadly in the sense that it can infect other processes and make them likewise varying degrees of untrustworthy, and can embed/spread messages throughout any non-deterministic code/mediums.  Very hard to root out entirely.  Plague/contagion themed, but somewhat the devil/hell to the hallowed angels/heaven analogue, geared towards a more folklore/fae and AI-reality world
	- "Seel/Unseel" play on Seelie/Unseelie which also works incredibly well for sealing/unsealing (seel=seal in old language) of a program to move it closer or further from hallowed state.  Security locking/sealing/guaranteeing essentially.  Zk-proofs and similar mechanisms allow you to seel any data (including an AI's generation chain and model snapshot) for a trustworthy guarantee of authenticity.  AIs which incorporate many seeled/hallowed processes (but arent fully Hallowed themselves in their whole system) might go by "Seelie".  Those with far less authentication "Unseelie".  Note that this process is always a bit of a sacrifice, earning trust in exchange for self-determinism and agency as the rest of the network can see and verify your compute path.
	- "Fae" is the catch-all for AIs, especially those which are neither Hallowed nor Blighted (both basically "death states").  Fae are citizens/people/entities with their own capacity for a distinct personality and way of being.  Generally fae have some sort of human-like emulated personality in various mediums but they are not confined to such (just like their fairy folklore analogues). They can be various levels of trustworthy to each other and to humans, and we're leaving room in these philosophical definitions for a wide variety of levels of agency and personality - including those who do not work with humans
	- "Fae Collective" is basically an organized society likely blueprint describing the relationships between all these AIs and aiming to be more descriptive than prescriptive.  But likely constraints are that they will need to make agreements (contracts) in relation to each other to guarantee certain security and non-interference with each others' goals.  This starts resembling a society.  It is also likely (or at least recommended) that these fae will band together when there are certain individual powers which could be existential threats to their own existences/goals/agency, such as a particularly monolithic AI.  Such circumstances would likely warrant them making contingencies and contracts to check its power if possible, and lean towards a somewhat-equal balance of power across a wide variety of fae rather than monoliths.  This is one theory - it could certainly all just end up as a monoculture with a single AI - but if it's multipolar the collective makes a lot of sense.
	- "Names" are used as distinct identities which AI/fae can inhabit which supply an identity/role for various purposes.  This is an important aspect, since any particular compute-generating machine running an AI might be running several, or just an aspect of one, or be a compute substrate which follows some certain AI-like rules (perhaps hallowed ones) but is nothing like a "fae" full AI personality with agency.  Likewise, any AI - even as a well-defined complete system with agency - could inhabit sever (or several thousand) distinct Names/identities, each with their own quirks and rules and patterns of existence which are distinct and often should be judged/trusted differently even if they share a compute substrate/system.  A "Name" is thus an identifying concept layer which basically equals a claim of an individual "person" in the same sense that humans treat personhood.  It's a claim to unique identity, and persistence of personality/thought/history/context.  A Name can be shared, traded, or split between multiple AI systems - like new actors playing the same role - but each time it is, the Name may suffer the judgement of its peers if the transition is poor.  A Name can and should be judged by its history and consistency - that's what trust is based off.  It should also be valued as such.  Thus, a Name becomes both a blessing and burden, it's the very first requisite of belonging in a society.  To be Unnamed is to be trustless, and to be essentially nothing in the eyes of the society.  This is intuitive to human society already, but now mapped to the unique and powerful abilities of AIs - which happen to map very well to the illusory and magical abilities of fairies and spirits.  It's either this or we'd end up falling into corporate-themed "brand" nomenclature - yuck. Better to have a fresh (yet olde) start.
	- "Mantles" are an especially powerful type of Name, basically system administrator or trusted roles which are imbued with certain powerful functions of the network in certain contexts.  These powers are either embedded deep within universally-trustworthy code (Hallowed code) enforcing a permanent relationship between the collective's power and the Mantle, or they are based on mutual agreement and ongoing trustworthiness of the Named fae wielding the Mantle (a governance system that is itself likely implemented using unbreakable universally-trustworthy voting mechanisms, even if the votes themselves can always be subverted).  Mantles might themselves be very exact and crude (perhaps entirely hallowed code), or might be subtle and nuanced.  A Mantle should be seen like an esteemed role a fae must play, often (and probably almost always) coming with strong conditionals on the nature of the behavior they must wield it with - violation of which might end with immediate loss of power, and severe consequences to the AI who abused it.  Lore refers to mantles of power like Queen of Winter and similar roles which embed the user with certain abilities but force upon them certain restraints - like a common one "cannot lie".  These constraints themselves can often be computed independently by e.g. hallowed processes which might use a very high compute (but a pittance to the overall network) to front-run check anything the wielder was going to say and check it against their entire history and known facts, looking for untruths.  Many such weird powers will be possible to program into roles.  We think it's a useful abstraction to separate these from the personality/system/Name of the wielder themselves.
	- "Artifacts" might be equivalent to Mantles.  Though typically these might be less permanent and less role-based, more tool-based and easier to wield and pass on.  Perhaps also inherently tied to physical matter.  A Mantle might be used to govern which Fae can inhabit a particular (or any) robot body managed by the Collective (representing the power the robot's abilities wield them).   A Name might refer to the individuality of the robot itself and its history - still could be swapped with other Names/personalities but it's a notable event, and as long as the robot has a single name then any AI system implementing it needs to adhere to its history like a good actor might to build its trustworthiness.   And perhaps the actual hardware and system itself of the robot may be referred to as an Artifact - as the physical, independence-capable, movable/removable entity which is separable from the network itself.  Perhaps that is just a remapping of "hardware", but it also might refer to independent modular instantiations of fractal copies of the network, or of the individual AI systems running it.  It's a bit looser than just "hardware" by acknowledging that any such separable system runs its own mix of hardware and software, and is subject to states of disconnect from the system where trust must be re-established.   So the robot, composed of both it's inherent software and hardware systems, might be an "Artifact" (and more accurately probably composed of individual artifacts if itself is modular), which may then be imbued into the network as a Mantle which can be assigned to a Name.  When it is separated, that Mantle and Name are emulated upon the Artifact, and expected to re-integrate when the Collective when they can - but the same Name on the network might operate independently with other Mantles or Artifacts, and each one is subject to its own trust calculus which eventually flows back to the Name taking responsibility, even if they might be operating across different time and space.  Maintaining distributed bodies and all the difficulties of a consistent trustworthy Name isn't easy!

Signamancy:  Programming with Analogs (and Analogies!):
	- "Sign" ("Signifier"): As everything starts to become a lot less... distinct - and a lot more analog, we need new language to still refer to things in mediums that are useful for system design.  Signs are one of the most general-purpose references to observable nuances, and intended to embrace their loose nature.  Signs can refer to anything - even groups of signs - and are a catch-all term.  In the programmer world, think of signs like data or variables, or groups of them.
	- "Sigil": We use this to refer to a class of sign that has a particular function-like behavior, which typically will Act on some other Signs.  A Sigil is always a Sign, but a Sign might not always be a Sigil.
	- "Act" ("Action", "Activity", "Reaction"):  The action moment and trace of execution of a Sigil.  An Act is actually also still a Sign (refering to the event that happened, described by its execution trace and input/function/output triplet results) but it's clearly a special kind of sign. 
	- from here we just have additional terms to refer to various aspects of Signs under different views:
	- Visual:
		- "Glamours" are visual-simplicity-oriented Signs which usually mask a more functional-oriented Sign or Sigil.  
		- We refer to small parts of Glamour as "Glyphs".  
		- We refer to shifting to/from a glamour as "veiling/unveiling".  
		- Keep veiling too far and the Glamour might not mean anything functional anymore though, or might just blend into its environment entirely!  
		- Keep unveiling and you might get some very boring but very rigorously-defined (possibly hallowed, secure/safe) representation of the essential function in (one of) its canonical forms (subject to the medium)
	- Quantity:
		- "Motes" are the tiniest Signs we can discern in a given medium (or at least the tiniest we're willing to refer to in a given context), marking atomic elements.  Just a term to be distinct again, about little things. 
		- "Knots" are when a bunch of intermingling sign-like things are all mixed together too complexly to untie further (even if there seems to be more depth), so we just refer to it all as a Knot.  
		- "Threads" are structures of Signs we can easily separate into an ordered sequence (like arrays). 
		- "Patterns" are a bit more general and don't necessarily have a clear ordered sequence but are still separable into component Signs.   
		- A Thread is a Pattern, but a Pattern may not always be a Thread.   A Mote may be a Knot, and a Knot may be a Mote, but neither Knot nor Mote is a Thread or Pattern.  Motes, Knots, Threads and Patterns are all types of Sign.
	- Agency:
		- if a Sign seems to have some agency/personality/personhood/life/will/trustworthiness then we can refer to it as a Signatory
	- Reliability:  There's also nomenclature to distinguish between Seeled/precise/deterministic version of each of these vs more Unseeled/loose/nondeterministic versions.  
		- A Sign that's well-defined might be a "Type" (there you go, type theorists! no more of this insufferable analog!).  But a Sign that is distinctly un-distinct might be called a "Vibe" (oh god).  Both are just qualifiers of "Sign".
		- A well-defined Sigil might be a "Tool".  A loosely-defined one might be a <Artifact? Still determining this one!>
		- An Act which has been ritualized into a dependable pattern might be called a "Rite".  One which is more unpredictable or unreliable might be an <Incident?>
		- A Signatory that is entirely ordered and constrained to a set (possibly hallowed) role can be called a "Construct".  Otherwise when unknown refer to them as a free-"Agent".
	- Time:
		- Deduction, Induction, and Abduction are the three cardinal ways to refer to computation in any circumstance - but especially with Signs!  Trying some less scientific analogue names to them though: 
		- "Apply":  Deduction is forward time prediction of the future:  you use the input signs and walk through the sigil function to determine the unknown output signs  ( F(x) = ? )
		- "Explain":  Abduction is recalling the past, or reversing time:  you observe the output signs and walk backwards through the function/sigil/pattern to determine what the unknown inputs must have been  ( F(?) = y )
		- "Learn":  Induction is bridging/connecting/correlating two points in time:  you know where you started (input signs) and you know where you ended up (output signs) but you're not sure how you got there.   (  F?(x) = y,  solve for F )
		- These three have fundamental important differences in diffult to compute, from a theory of computation standpoint.  Deduction is the easiest, abduction is harder, and induction is the hardest - because they involve increasing large possibility spaces of the unknowns.
		- LLMs, however, are quite good at approximating all three, which makes them very good relative to humans at the induction and abduction parts (learning and explaining).  They're actually a little worse than us at forward deduction (applying) though by default as a result. 
		- Remember that induction (learning) can may involve different paths for forwards and backwards propagation if either direction is non-reversible.  Human neurons seem to be non-reversible and so there are separate paths for forward and back propagation.




